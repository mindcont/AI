### 2.2.3 OPEN表的引入    

**鉴于上述情况，引进了新的OPEN表，以便能从走入尽头的情况中退出来。**OPEN表用来存放以后能够扩展的候选状态。新的算法这时变成为下列形式的算法。  

**算法3**  OPEN表的引人    

    第1步:将初始节点存放到OPEN表中;   
    第2步:从()PEN表中取出节点，并且设其为n。
          如果OPEN表是空的，则求解以失败告终。
          如果节点n是目标节点，则求解以成功告终;    
    第3步:扩展节点n，得到子节点的集合。将n加到CLOSED表中;
    第4步:对于子节点集合中不包含在CLOSED表中的节点，配置指向节点n的指针;    
    第5步:返回第2步。    
    
在这种算法中，扩展的节点顺序，并不构成原来求解的路径。

因此，是通过指针(从子节点指向双亲节点的转移指令)来表示扩展的双亲节点与子节点的关系。当到达目标节点时，通过追踪指针就可以得到求解路径。这个算法如下面表示的那样，其搜索图是有限的，如果解存在，则必定能找到解的这种所谓安全性会得到保证。

**定理2. 1** 对于解存在的有限搜索图，算法3必然能找到解。    
**<证明>** 下面两种情况中的任何一种都是不能找到解的情况。

> (a)陷入无限循环之中;
> 
> (b)在第2步中，OPEN表变空，从而以失败告终。

因为根据命题2. l不可能发生情况(a),所以假定是情况(b)。
由于必定存在着解，所以可以设其节点序列为N1，n2，...Nm。这里N1是初始节点，Nm是目标节点。在这些节点中，设未包含在closed表中且下脚标最大的节点为Ni。于是Ni必然包含在CLOSED表内，因为Nm不包含在closed表内，所以上述Ni必然存在。这时Ni-1包含在CLOSED表内。这样一来就能对Ni-1进行扩展，作为其子状态之一的Ni理应包含在OPEN表内。因为Ni未包含在CLOSED表内，而且尚未被扩展，所以OPEN表不会是空的。这与(b>中的最终结果相矛盾。

---
** 整理:[mindcont](https://github.com/mindcont)-原著 《人工智能》 [日]沟口理一郎 石田 亨编 **

2016-04-21 第一次编辑